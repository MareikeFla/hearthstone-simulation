{"ast":null,"code":"import CardDefinitions from \"../Components/CardDefinitions\";\nfunction fight(card1, card2) {\n  let myCard = {\n    ...card1\n  };\n  let opponent = {\n    ...card2\n  };\n  let result = null;\n\n  // Prevent endless loop when both have 0 attack\n  if (myCard.attack === 0 && opponent.attack === 0) {\n    return \"draw\";\n  }\n  console.log(myCard.health);\n  // Check for Divine Shield and simulate the first attack without getting damaged\n\n  if (myCard.keywords.includes(\"Divine Shield\")) {\n    opponent.health = opponent.health - myCard.attack;\n    myCard.keywords.splice(myCard.keywords.findIndex(keyword => keyword === \"Divine Shield\"), myCard.keywords.findIndex(keyword => keyword === \"Divine Shield\"));\n    console.log(myCard.health);\n    console.log(opponent.health);\n  }\n  if (opponent.keywords.includes(\"Divine Shield\")) {\n    myCard.health = myCard.health - opponent.attack;\n    opponent.keywords.splice(opponent.keywords.findIndex(keyword => keyword === \"Divine Shield\"), opponent.keywords.findIndex(keyword => keyword === \"Divine Shield\"));\n  }\n\n  // Simulate the fight until one card has 0/<0 health\n  while (myCard.health > 0 && opponent.health > 0) {\n    myCard.health = myCard.health - opponent.attack;\n    opponent.health = opponent.health - myCard.attack;\n  }\n\n  // Return result\n  if (myCard.health > 0) {\n    result = \"win\";\n  } else if (opponent.health > 0) {\n    result = \"loose\";\n  } else {\n    result = \"draw\";\n  }\n  return result;\n}\nexport function fightAll(myCard) {\n  let results = CardDefinitions.map(opponent => {\n    return fight(myCard, opponent);\n  });\n  return {\n    win: results.filter(result => result === \"win\").length,\n    loose: results.filter(result => result === \"loose\").length,\n    draw: results.filter(result => result === \"draw\").length\n  };\n}","map":{"version":3,"names":["CardDefinitions","fight","card1","card2","myCard","opponent","result","attack","console","log","health","keywords","includes","splice","findIndex","keyword","fightAll","results","map","win","filter","length","loose","draw"],"sources":["/Users/mareike/Projekte/hearthstone/src/lib/fight.js"],"sourcesContent":["import CardDefinitions from \"../Components/CardDefinitions\";\n\nfunction fight(card1, card2) {\n  let myCard = { ...card1 };\n  let opponent = { ...card2 };\n  let result = null;\n\n  // Prevent endless loop when both have 0 attack\n  if (myCard.attack === 0 && opponent.attack === 0) {\n    return \"draw\";\n  }\n  console.log(myCard.health);\n  // Check for Divine Shield and simulate the first attack without getting damaged\n\n  if (myCard.keywords.includes(\"Divine Shield\")) {\n    opponent.health = opponent.health - myCard.attack;\n    myCard.keywords.splice(\n      myCard.keywords.findIndex((keyword) => keyword === \"Divine Shield\"),\n      myCard.keywords.findIndex((keyword) => keyword === \"Divine Shield\")\n    );\n    console.log(myCard.health);\n    console.log(opponent.health);\n  }\n  if (opponent.keywords.includes(\"Divine Shield\")) {\n    myCard.health = myCard.health - opponent.attack;\n    opponent.keywords.splice(\n      opponent.keywords.findIndex((keyword) => keyword === \"Divine Shield\"),\n      opponent.keywords.findIndex((keyword) => keyword === \"Divine Shield\")\n    );\n  }\n\n  // Simulate the fight until one card has 0/<0 health\n  while (myCard.health > 0 && opponent.health > 0) {\n    myCard.health = myCard.health - opponent.attack;\n    opponent.health = opponent.health - myCard.attack;\n  }\n\n  // Return result\n  if (myCard.health > 0) {\n    result = \"win\";\n  } else if (opponent.health > 0) {\n    result = \"loose\";\n  } else {\n    result = \"draw\";\n  }\n  return result;\n}\n\nexport function fightAll(myCard) {\n  let results = CardDefinitions.map((opponent) => {\n    return fight(myCard, opponent);\n  });\n  return {\n    win: results.filter((result) => result === \"win\").length,\n    loose: results.filter((result) => result === \"loose\").length,\n    draw: results.filter((result) => result === \"draw\").length,\n  };\n}\n"],"mappings":"AAAA,OAAOA,eAAe,MAAM,+BAA+B;AAE3D,SAASC,KAAKA,CAACC,KAAK,EAAEC,KAAK,EAAE;EAC3B,IAAIC,MAAM,GAAG;IAAE,GAAGF;EAAM,CAAC;EACzB,IAAIG,QAAQ,GAAG;IAAE,GAAGF;EAAM,CAAC;EAC3B,IAAIG,MAAM,GAAG,IAAI;;EAEjB;EACA,IAAIF,MAAM,CAACG,MAAM,KAAK,CAAC,IAAIF,QAAQ,CAACE,MAAM,KAAK,CAAC,EAAE;IAChD,OAAO,MAAM;EACf;EACAC,OAAO,CAACC,GAAG,CAACL,MAAM,CAACM,MAAM,CAAC;EAC1B;;EAEA,IAAIN,MAAM,CAACO,QAAQ,CAACC,QAAQ,CAAC,eAAe,CAAC,EAAE;IAC7CP,QAAQ,CAACK,MAAM,GAAGL,QAAQ,CAACK,MAAM,GAAGN,MAAM,CAACG,MAAM;IACjDH,MAAM,CAACO,QAAQ,CAACE,MAAM,CACpBT,MAAM,CAACO,QAAQ,CAACG,SAAS,CAAEC,OAAO,IAAKA,OAAO,KAAK,eAAe,CAAC,EACnEX,MAAM,CAACO,QAAQ,CAACG,SAAS,CAAEC,OAAO,IAAKA,OAAO,KAAK,eAAe,CACpE,CAAC;IACDP,OAAO,CAACC,GAAG,CAACL,MAAM,CAACM,MAAM,CAAC;IAC1BF,OAAO,CAACC,GAAG,CAACJ,QAAQ,CAACK,MAAM,CAAC;EAC9B;EACA,IAAIL,QAAQ,CAACM,QAAQ,CAACC,QAAQ,CAAC,eAAe,CAAC,EAAE;IAC/CR,MAAM,CAACM,MAAM,GAAGN,MAAM,CAACM,MAAM,GAAGL,QAAQ,CAACE,MAAM;IAC/CF,QAAQ,CAACM,QAAQ,CAACE,MAAM,CACtBR,QAAQ,CAACM,QAAQ,CAACG,SAAS,CAAEC,OAAO,IAAKA,OAAO,KAAK,eAAe,CAAC,EACrEV,QAAQ,CAACM,QAAQ,CAACG,SAAS,CAAEC,OAAO,IAAKA,OAAO,KAAK,eAAe,CACtE,CAAC;EACH;;EAEA;EACA,OAAOX,MAAM,CAACM,MAAM,GAAG,CAAC,IAAIL,QAAQ,CAACK,MAAM,GAAG,CAAC,EAAE;IAC/CN,MAAM,CAACM,MAAM,GAAGN,MAAM,CAACM,MAAM,GAAGL,QAAQ,CAACE,MAAM;IAC/CF,QAAQ,CAACK,MAAM,GAAGL,QAAQ,CAACK,MAAM,GAAGN,MAAM,CAACG,MAAM;EACnD;;EAEA;EACA,IAAIH,MAAM,CAACM,MAAM,GAAG,CAAC,EAAE;IACrBJ,MAAM,GAAG,KAAK;EAChB,CAAC,MAAM,IAAID,QAAQ,CAACK,MAAM,GAAG,CAAC,EAAE;IAC9BJ,MAAM,GAAG,OAAO;EAClB,CAAC,MAAM;IACLA,MAAM,GAAG,MAAM;EACjB;EACA,OAAOA,MAAM;AACf;AAEA,OAAO,SAASU,QAAQA,CAACZ,MAAM,EAAE;EAC/B,IAAIa,OAAO,GAAGjB,eAAe,CAACkB,GAAG,CAAEb,QAAQ,IAAK;IAC9C,OAAOJ,KAAK,CAACG,MAAM,EAAEC,QAAQ,CAAC;EAChC,CAAC,CAAC;EACF,OAAO;IACLc,GAAG,EAAEF,OAAO,CAACG,MAAM,CAAEd,MAAM,IAAKA,MAAM,KAAK,KAAK,CAAC,CAACe,MAAM;IACxDC,KAAK,EAAEL,OAAO,CAACG,MAAM,CAAEd,MAAM,IAAKA,MAAM,KAAK,OAAO,CAAC,CAACe,MAAM;IAC5DE,IAAI,EAAEN,OAAO,CAACG,MAAM,CAAEd,MAAM,IAAKA,MAAM,KAAK,MAAM,CAAC,CAACe;EACtD,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}